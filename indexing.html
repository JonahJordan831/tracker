<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>BerryIMU 3D Viewer</title>
  <style>
    body {
      margin: 0;
      background: #111;
      color: #eee;
      font-family: Arial, sans-serif;
      overflow: hidden;
    }
    #ui {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 10;
      background: rgba(0,0,0,0.6);
      padding: 10px 14px;
      border-radius: 6px;
    }
    button {
      padding: 6px 12px;
      margin-right: 8px;
    }
    #status {
      margin-top: 6px;
      font-size: 0.9rem;
    }
    #angles {
      position: absolute;
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
      color: #ccc;
      background: rgba(0,0,0,0.6);
      padding: 6px 10px;
      border-radius: 6px;
      font-family: monospace;
      font-size: 0.9rem;
      z-index: 10;
    }
  </style>
</head>
<body>
  <div id="ui">
    <button id="connectBtn">Connect to IMU</button>
    <div id="status">Status: Not connected</div>
  </div>

  <div id="angles">R=0.00°  P=0.00°  Y=0.00°</div>

  <!-- Three.js from CDN -->
  <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>

  <script>
    let port = null;
    let reader = null;

    let scene, camera, renderer, box;

    function initThree() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x111111);

      const width = window.innerWidth;
      const height = window.innerHeight;

      camera = new THREE.PerspectiveCamera(60, width / height, 0.1, 100);
      camera.position.set(0, 0, 5);

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(width, height);
      document.body.appendChild(renderer.domElement);

      const ambient = new THREE.AmbientLight(0xffffff, 0.4);
      scene.add(ambient);

      const dir = new THREE.DirectionalLight(0xffffff, 0.8);
      dir.position.set(5, 5, 5);
      scene.add(dir);

      // 3D rectangle (the IMU object)
      const boxGeom = new THREE.BoxGeometry(2.0, 0.3, 0.8);
      const boxMat = new THREE.MeshStandardMaterial({
        color: 0x0077ff,
        metalness: 0.2,
        roughness: 0.4
      });
      box = new THREE.Mesh(boxGeom, boxMat);
      scene.add(box);

      // Light gray wireframe sphere snug around the rectangle
      const sphereGeom = new THREE.SphereGeometry(1.3, 24, 24);
      const sphereMat = new THREE.MeshBasicMaterial({
        color: 0x777777,
        wireframe: true,
        opacity: 0.5,
        transparent: true
      });
      const sphere = new THREE.Mesh(sphereGeom, sphereMat);
      scene.add(sphere);

      window.addEventListener("resize", onWindowResize);
      animate();
    }

    function onWindowResize() {
      const width = window.innerWidth;
      const height = window.innerHeight;
      camera.aspect = width / height;
      camera.updateProjectionMatrix();
      renderer.setSize(width, height);
    }

    function animate() {
      requestAnimationFrame(animate);
      renderer.render(scene, camera);
    }

    // Apply roll, pitch, yaw (deg) to the box and update numeric display
    function setOrientation(rollDeg, pitchDeg, yawDeg) {
      const r = THREE.MathUtils.degToRad(rollDeg);
      const p = THREE.MathUtils.degToRad(pitchDeg);
      const y = THREE.MathUtils.degToRad(yawDeg);

      // Reset then apply ZYX Euler (yaw, pitch, roll)
      box.rotation.set(0, 0, 0);
      box.rotateZ(y);
      box.rotateY(p);
      box.rotateX(r);

      const angleEl = document.getElementById("angles");
      angleEl.textContent =
        `R=${rollDeg.toFixed(2)}°  P=${pitchDeg.toFixed(2)}°  Y=${yawDeg.toFixed(2)}°`;
    }

    async function connectSerial() {
      const statusEl = document.getElementById("status");

      if (!("serial" in navigator)) {
        statusEl.textContent = "Status: Web Serial not supported.";
        return;
      }

      try {
        port = await navigator.serial.requestPort();
        await port.open({ baudRate: 115200 });

        statusEl.textContent = "Status: Connected. Reading data...";

        const decoder = new TextDecoderStream();
        const inputDone = port.readable.pipeTo(decoder.writable);
        reader = decoder.readable.getReader();

        let buffer = "";

        while (true) {
          const { value, done } = await reader.read();
          if (done) break;
          if (!value) continue;

          buffer += value;
          let lines = buffer.split("\n");
          buffer = lines.pop(); // keep last incomplete line

          for (const line of lines) {
            const trimmed = line.trim();
            if (!trimmed) continue;

            // Only accept pure CSV lines: roll,pitch,yaw
            const parts = trimmed.split(",");
            if (parts.length !== 3) continue;

            const roll = parseFloat(parts[0]);
            const pitch = parseFloat(parts[1]);
            const yaw = parseFloat(parts[2]);
            if (Number.isNaN(roll) || Number.isNaN(pitch) || Number.isNaN(yaw)) {
              continue;
            }

            setOrientation(roll, pitch, yaw);
          }
        }

        await reader.releaseLock();
        await inputDone;
      } catch (err) {
        console.error(err);
        statusEl.textContent = "Status: Error - " + err;
      } finally {
        if (port) {
          try { await port.close(); } catch {}
        }
        statusEl.textContent = "Status: Disconnected";
      }
    }

    document.getElementById("connectBtn").addEventListener("click", () => {
      connectSerial();
    });

    initThree();
  </script>
</body>
</html>
